## 1. What is the Big O for this?
### 1) Determine the Big O for the following algorithm: 
**You are sitting 
in a room with 15 people. You want to find a playmate for your dog,
preferably of the same breed. So you want to know if anyone out of the
15 people have the same breed as your dog. You stand up and yell out,
who here has a golden retriever and would like to be a playdate for my
golden. Someone yells - "I do, be happy to bring him over".**

I think this will be a Constant time O(1) because you are saving time by asking one time to everyone at the same time and getting back one response.

### 2) Determine the Big O for the following algorithm: 
**You are sitting in a
room with 15 people. You want to find a playmate for your dog who is of
the same breed. So you want to know if anyone out of the 15 people
have the same breed as your dog. You start with the first person and ask
him if he has a golden retriever. He says no, then you ask the next
person, and the next, and the next until you find someone who has a
golden or there is no one else to ask.**

This case will be a Linear time O(n) because you will be asking your same question to each person individually in the room. The number of operations(questions) required to complete grows with input size.
Linear time complexities have running times directly proportional to the size of the input.


## 2. Even or odd
### What is the Big O of the following algorithm? Explain your answer

`function isEven(value) {
    if (value % 2 == 0) {
        return true;
    }
    else
        return false;
    }
}`

This algorithm is Constant time O(n). You enter one value and return one value after you determine it is even or not. The same amount of time will be taken for each input.

## 3. Are you here?
### What is the Big O of the following algorithm? Explain your answer

`function areYouHere(arr1, arr2) {
    for (let i = 0; i < arr1.length; i++) {
        const el1 = arr1[i];
        for (let j = 0; j < arr2.length; j++) {
            const el2 = arr2[j];
            if (el1 === el2) return true;
        }
    }
    return false;
}`

This is a polynomial time O(n^2). The time complexity will grow faster than the input size. The nested for loops raise the input size to the power of 2. There's many operations taking place that will vary with different input sizes and values.

## 4. Doubler
### What is the Big O of the following algorithm? Explain your answer

`function doubleArrayValues(array) {
    for (let i = 0; i < array.length; i++) {
        array[i] *= 2;
    }
    return array;
}
`

This is a linear time O(n). The double operation is completed for each item in an array. The number of operations will grow proportional with the size of the array input.

## 5. Naive search
### What is the Big O of the following algorithm? Explain your answer

`function naiveSearch(array, item) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === item) {
            return i;
        }
    }
}`

This could be constant O(1) or linear time O(n). For constant, the item could be the first item of a small or big array and return it right away. For linear, the item could be elsewhere in the array of the last item which would take more time to find different arrays sizes.

## 6. Creating pairs:
### What is the Big O of the following algorithm? Explain your answer

`function createPairs(arr) {
    for (let i = 0; i < arr.length; i++) {
        for(let j = i + 1; j < arr.length; j++) {
            console.log(arr[i] + ", " +  arr[j] );
        }
    }
}`

This is a polynomial time O(n^2). The time complexity will grow faster than the input size. The nested for loops raise the input size to the power of 2. There's many operations taking place that will vary with different array sizes.

## 7. Compute the sequence
### What does the following algorithm do? What is its runtime complexity? Explain your answer

`function compute(num) {
    let result = [];
    for (let i = 1; i <= num; i++) {

        if (i === 1) {
            result.push(0);
        }
        else if (i == 2) {
            result.push(1);
        }
        else {
            result.push(result[i - 2] + result[i - 3]);
        }
    }
    return result;
}`

The algorithm push numbers into an array that gets returned. A sequence is being generated by a given number and starts with [0, 1, ...]. The sequence is a Fibonacci sequence because a number in the array is equal to the sum of the two numbers before it. The runtime will increase along with increasing number values so this alogrithm is Linear O(n). If the input was 1 then the algorithm will push 1 and return it. If the input was 2 then the algorithm will push 2, then push 1, and return it. The number of operations will be proportional to the input number.

## 8. An efficient search
### In this example, we return to the problem of searching using a more sophisticated approach than in naive search, above. Assume that the input array is always sorted. What is the Big O of the following algorithm? Explain your answer

`function efficientSearch(array, item) {
    let minIndex = 0;
    let maxIndex = array.length - 1;
    let currentIndex;
    let currentElement;

    while (minIndex <= maxIndex) {
        currentIndex = Math.floor((minIndex + maxIndex) / 2);
        currentElement = array[currentIndex];

        if (currentElement < item) {
            minIndex = currentIndex + 1;
        }
        else if (currentElement > item) {
            maxIndex = currentIndex - 1;
        }
        else {
            return currentIndex;
        }
    }
    return -1;
}`
