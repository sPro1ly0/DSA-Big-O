## 1. What is the Big O for this?
### 1) Determine the Big O for the following algorithm: 
**You are sitting 
in a room with 15 people. You want to find a playmate for your dog,
preferably of the same breed. So you want to know if anyone out of the
15 people have the same breed as your dog. You stand up and yell out,
who here has a golden retriever and would like to be a playdate for my
golden. Someone yells - "I do, be happy to bring him over".**

I think this will be a Constant time O(1) because you are saving time by asking one time to everyone at the same time and getting back one response.

### 2) Determine the Big O for the following algorithm: 
**You are sitting in a
room with 15 people. You want to find a playmate for your dog who is of
the same breed. So you want to know if anyone out of the 15 people
have the same breed as your dog. You start with the first person and ask
him if he has a golden retriever. He says no, then you ask the next
person, and the next, and the next until you find someone who has a
golden or there is no one else to ask.**

This case will be a Linear time O(n) because you will be asking your same question to each person individually in the room. The number of operations(questions) required to complete grows with input size.
Linear time complexities have running times directly proportional to the size of the input.


## 2. Even or odd
### What is the Big O of the following algorithm? Explain your answer

<pre><code>function isEven(value) {
    if (value % 2 == 0) {
        return true;
    }
    else
        return false;
    }
}</code></pre>

This algorithm is Constant time O(n). You enter one value and return one value after you determine it is even or not. The same amount of time will be taken for each input.

## 3. Are you here?
### What is the Big O of the following algorithm? Explain your answer

<pre><code>function areYouHere(arr1, arr2) {
    for (let i = 0; i < arr1.length; i++) {
        const el1 = arr1[i];
        for (let j = 0; j < arr2.length; j++) {
            const el2 = arr2[j];
            if (el1 === el2) return true;
        }
    }
    return false;
}</code></pre>

This is a polynomial time O(n^2). The time complexity will grow faster than the input size. The nested for loops raise the input size to the power of 2. There's many operations taking place that will vary with different input sizes and values.

## 4. Doubler
### What is the Big O of the following algorithm? Explain your answer

<pre><code>function doubleArrayValues(array) {
    for (let i = 0; i < array.length; i++) {
        array[i] *= 2;
    }
    return array;
}
</code></pre>

This is a linear time O(n). The double operation is completed for each item in an array. The number of operations will grow proportional with the size of the array input.

## 5. Naive search
### What is the Big O of the following algorithm? Explain your answer

<pre><code>function naiveSearch(array, item) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === item) {
            return i;
        }
    }
}</code></pre>

This could be constant O(1) or linear time O(n). For constant, the item could be the first item of a small or big array and return it right away. For linear, the item could be elsewhere in the array or the last item which would take more time to find different arrays sizes.

## 6. Creating pairs:
### What is the Big O of the following algorithm? Explain your answer

<pre><code>function createPairs(arr) {
    for (let i = 0; i < arr.length; i++) {
        for(let j = i + 1; j < arr.length; j++) {
            console.log(arr[i] + ", " +  arr[j] );
        }
    }
}</code></pre>

This is a polynomial time O(n^2). The time complexity will grow faster than the input size. The nested for loops raise the input size to the power of 2. There's many operations taking place that will vary with different array sizes.

## 7. Compute the sequence
### What does the following algorithm do? What is its runtime complexity? Explain your answer

<pre><code>function compute(num) {
    let result = [];
    for (let i = 1; i <= num; i++) {

        if (i === 1) {
            result.push(0);
        }
        else if (i == 2) {
            result.push(1);
        }
        else {
            result.push(result[i - 2] + result[i - 3]);
        }
    }
    return result;
}</code></pre>

The algorithm push numbers into an array that gets returned. A sequence is being generated by a given number and starts with [0, 1, ...]. The sequence is a Fibonacci sequence because a number in the array is equal to the sum of the two numbers before it. 

The runtime will increase along with increasing number values so this alogrithm is Linear O(n). If the input was 1 then the algorithm will push 1 and return it. If the input was 2 then the algorithm will push 2, then push 1, and return it. The number of operations will be proportional to the input number.

## 8. An efficient search
### In this example, we return to the problem of searching using a more sophisticated approach than in naive search, above. Assume that the input array is always sorted. What is the Big O of the following algorithm? Explain your answer

<pre><code>function efficientSearch(array, item) {
    let minIndex = 0;
    let maxIndex = array.length - 1;
    let currentIndex;
    let currentElement;

    while (minIndex <= maxIndex) {
        currentIndex = Math.floor((minIndex + maxIndex) / 2);
        currentElement = array[currentIndex];

        if (currentElement < item) {
            minIndex = currentIndex + 1;
        }
        else if (currentElement > item) {
            maxIndex = currentIndex - 1;
        }
        else {
            return currentIndex;
        }
    }
    return -1;
}</code></pre>

I think this is a logarithmic time O(log(n)). The run will increase with big inputs but slowly because the problem gets smaller. The currentIndex will increase the minIndex or decrease the maxIndex which focuses on a smaller section of the array.

## 9. Random element
### What is the Big O of the following algorithm? Explain your answer

<pre><code>
function findRandomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}
</code></pre>

The Big O here is a Constant time O(1). The algorithm will generate a random index number based on any array input length and use it to return one value at that index. The same process is happening for any array.

## 10. What Am I?
### What does the following algorithm do? What is the Big O of the following algorithm? Explain your answer

<pre><code>
function isWhat(n) {
    if (n < 2 || n % 1 != 0) {
        return false;
    }
    for (let i = 2; i < n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}
</code></pre>

This alogrithm is trying to help find prime numbers which would leave some remainder and not a remainder of zero here. Prime numbers are only divisible by 1 and themseleves. If the for loop let i = 1 then all the prime numbers would return false, so the for loop started i = 2 to avoid this from happening.

The Big O is constant or linear time. The first 'if' statement deals with numbers less than 2 which return false right away, or if the number was 2 then it would return true right away(constant). The linear time in the 'for' statement will vary on the number values greater than 2. If the number is a prime number, then the for loop will go through each number from 2 to the prime number which would result in operations being proportional to the number. Other numbers than prime numbers would be shorter in time because the remainder could be equal to 0 earlier.

## 11. Tower of Hanoi
### Derive an algorithm to solve the Tower of Hanoi puzzle.
#### Implement your algorithm using recursion. Your program should display each movement of the disk from one rod to another.
Alogrithm is in recursive-problems.js. 
https://github.com/sPro1ly0/DSA-Big-O/blob/master/recursive-problems.js

#### If you are given 5 disks, how do the rods look like after 7 recursive calls?

After 7 recursive calls, only 2 moves were figured out. The top disk is moved to rod C or the end rod. The next disk was moved to rod B or the middle rod.

#### How many moves are needed to complete the puzzle with 3 disks? with 4 disks? with 5 disks?

3 disks: 7 moves, 4 disks: 15 moves, 5 disks: 31 moves

#### What is the runtime of your algorithm?

Exponential time O(2^n). The amount of moves increases very quickly with increasing number of disks. Many recursive calls and operations are required to complete the alogrithm.

## 12. Iterative version & 14. Big O
### Solve the drills 1 - 7 from your previous checkpoint (Recursion) iteratively.
### Take your solutions from the iterative exercises today and identify the time complexities (big O) of each of them.

https://github.com/sPro1ly0/DSA-Big-O/blob/master/recursive-problems.js

## 13. Recursive Big O
### Take your solutions from the recursive exercises that you completed in the previous checkpoint and identify the time complexities (big O) of each of them.

1. Counting Sheep

<pre><code>
const countingSheep = function(numberOfSheep) {
    // Base case
    if (numberOfSheep === 0) {
        return console.log('All sheep jumped over the fence');
    }
    // recursive case
    
    console.log(`${numberOfSheep}: Another sheep jumps over the fence`);
    countingSheep(numberOfSheep - 1);
    
};
</code></pre>


2. Power Calculator

<pre><code>
const powerCalculator = function(base, exponent) {

    if (exponent < 0) {
        return 'exponent should be >= 0';
    } else if (exponent === 0 ) {
        return 1;
    } else {
        return base * powerCalculator(base, exponent - 1);
    }

}
</code></pre>

3. Reverse String

<pre><code>
const reverseString = function(str) {
    let shortenStr = str.slice(0, str.length - 1)

    if (str.length === 0) {
        return "";
    }


    return str.charAt(str.length - 1) + reverseString(shortenStr);
}
</code></pre>

4. nth Triangular Number

<pre><code>
const triangle = function(num) {
    if (num <= 0) {
        return 0;
    }

    return num + triangle(num - 1);
}
</code></pre>

5. String Splitter

<pre><code>
const stringSplitter = function(str) {
    let slash = str.search('/');
    let splitOutSlash = str.slice(0, slash);

    if (slash == -1) {
        splitOutSlash = str;
        return [ splitOutSlash ];
    }

    return [ splitOutSlash, ...stringSplitter(str.slice(slash + 1)) ];
}

// console.log(stringSplitter('02/20/2020'));
</code></pre>

6. Fibonacci

<pre><code>
let fibonacci = function(num) {
    
    if (num === 1) {
        return [0, 1];
    } else {
        let arr = fibonacci(num - 1);
        arr.push(arr[arr.length - 1] + arr[arr.length - 2]);
        return arr;
    }

}
</code></pre>

7. Factorial

<pre><code>
const factorial = function(num) {

    if (num === 0) {
        return 1;
    } else if (Math.sign(num) === -1) { // for negative numbers
        return num * factorial(num + 1);
    } else if (Math.sign(num) === 1) { // for positive numbers
        return num * factorial(num - 1);
    }
}
</code></pre>

// DID NOT SOLVE MAZE PROBLEM

<pre><code>
const solveMaze = function(maze) {

    const m = maze;

    const move = function(row, column) {
        
        if(m[row][column] == 2) {
            console.log("We solved the maze at (" + column + ", " + row + ")");
        } else if(m[row][column] == 1) {
            console.log("At valid position (" + column + ", " + row + ")");
            m[row][column] = 9;
            if(column < m.length - 1) {  // right
              console.log('R')
                move(column + 1, row);
            }
            if(row < m[column].length - 1) {  //down
              console.log('D')
                move(column, row + 1);
            }
            if(column > 0) {  // left
              console.log('L')
                move(column - 1, row);
            }
            if(row > 0) {  // up
              console.log('U')
                move(column, row - 1);
            }
        }
    }
}
</code></pre>


// 10. Anagrams

<pre><code>
const anagrams = function(prefix, word) {

    if (word.length <= 1) {
        console.log(prefix + word);
    } else {
        for (let i = 0; i < word.length; i++) {
            const nextLetter = word.substring(i, i + 1);
            const before = word.substring(0, i);
            const after = word.substring(i + 1);
            anagrams(prefix + nextLetter, before + after);
        }
    }

}

// anagrams('', 'east');
</code></pre>

11. Organization Chart

<pre><code>
const organizationChart = function(org, boss) {

    let hierarchy = {};
    
    org
        .filter(person => person.boss === boss)
        .forEach(person => hierarchy[person.name] = organizationChart(org, person.name))

    return hierarchy;
}

// console.log(organizationChart(group, null));
</code></pre>

12. Binary Representation

<pre><code>
function binaryRep(num) {
    if (num === 0) {
        return '0';
    }
    const divideNum = Math.floor(num / 2);
    const remainder = num % 2;
    if (divideNum === 0) {
        return `${remainder}`;
    }
    return binaryRep(divideNum) + remainder.toString();
  };
  
// console.log(binaryRep(3));
// console.log(binaryRep(25));
</code></pre>